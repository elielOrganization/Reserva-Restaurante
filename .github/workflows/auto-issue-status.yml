name: ðŸ”„ Actualizar estado de Issues automÃ¡ticamente

on:
  issues:
    types: [assigned, unassigned]
  pull_request:
    types: [closed]

permissions:
  issues: write
  pull-requests: write

jobs:
  update-status:
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ§  Detectar evento y actualizar etiqueta
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Utilidad para buscar comentario oculto de etiquetas
            async function findLabelsComment(issue_number) {
              const comments = await github.rest.issues.listComments({ owner, repo, issue_number });
              return comments.data.find(c => c.body && c.body.startsWith('<!--LABELS:'));
            }

            // ðŸŸ¡ Caso 1: Se asigna un issue â†’ guardar etiquetas originales y poner "in progress"
            if (context.eventName === 'issues' && context.payload.action === 'assigned') {
              const issue = context.payload.issue;
              const labels = issue.labels.map(l => l.name);
              if (!labels.includes('ðŸš§ in progress') || labels.length > 1) {
                // Guardar todas las etiquetas actuales (excepto "ðŸš§ in progress") en comentario oculto
                const labelsToSave = labels.filter(l => l !== 'ðŸš§ in progress');
                if (labelsToSave.length > 0) {
                  await github.rest.issues.createComment({
                    owner,
                    repo,
                    issue_number: issue.number,
                    body: `<!--LABELS:${labelsToSave.join(',')}-->`
                  });
                }
                // Reemplazar todas las etiquetas por solo "ðŸš§ in progress"
                await github.rest.issues.setLabels({
                  owner,
                  repo,
                  issue_number: issue.number,
                  labels: ['ðŸš§ in progress']
                });
                console.log(`ðŸš§ Issue #${issue.number} ahora solo tiene la etiqueta "ðŸš§ in progress" y las anteriores fueron guardadas`);
              } else {
                console.log(`ðŸš§ Issue #${issue.number} ya tiene solo la etiqueta "ðŸš§ in progress"`);
              }
            }

            // ðŸ”´ Caso 2: Se desasigna un issue â†’ restaurar etiquetas originales si hay comentario
            if (context.eventName === 'issues' && context.payload.action === 'unassigned') {
              const issue = context.payload.issue;
              // Buscar comentario oculto y restaurar etiquetas
              const labelsComment = await findLabelsComment(issue.number);
              let restored = false;
              if (labelsComment) {
                // Permitir emojis y caracteres especiales en etiquetas
                const match = labelsComment.body.match(/<!--LABELS:([\s\S]+?)-->/);
                if (match) {
                  const prevLabels = match[1].split(',').map(l => l.trim()).filter(Boolean);
                  if (prevLabels.length > 0) {
                    // Reemplazar todas las etiquetas actuales por las originales
                    await github.rest.issues.setLabels({
                      owner,
                      repo,
                      issue_number: issue.number,
                      labels: prevLabels
                    });
                    restored = true;
                    console.log(`ðŸ”™ Etiquetas originales restauradas: ${prevLabels.join(', ')}`);
                  }
                }
                // Borrar comentario oculto
                await github.rest.issues.deleteComment({
                  owner,
                  repo,
                  comment_id: labelsComment.id
                });
              }
              // Si no habÃ­a comentario, solo quitar "ðŸš§ in progress" si estÃ¡
              if (!restored) {
                const labels = issue.labels.map(l => l.name);
                if (labels.includes('ðŸš§ in progress')) {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: issue.number,
                    name: 'ðŸš§ in progress'
                  });
                  console.log(`ðŸ” Etiqueta "ðŸš§ in progress" eliminada del issue #${issue.number}`);
                }
              }
            }

            // ðŸŸ¢ Caso 3: Se mergea un PR â†’ marcar issue como "done"
            if (context.eventName === 'pull_request' && context.payload.pull_request.merged) {
              const prBody = context.payload.pull_request.body || '';
              const issueMatch = prBody.match(/#(\d+)/);

              if (!issueMatch) {
                console.log('No se encontrÃ³ un issue vinculado.');
                return;
              }

              const issue_number = issueMatch[1];
              const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number });
              const existingLabels = issue.labels.map(l => l.name).filter(l => l !== 'ðŸš§ in progress' && l !== 'âœ… done');

              await github.rest.issues.setLabels({
                owner,
                repo,
                issue_number,
                labels: [...existingLabels, 'âœ… done']
              });

              console.log(`âœ… Issue #${issue_number} marcado como "âœ… done"`);
            }